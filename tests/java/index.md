---
title: Тестовое задание на позицию Java разработчика
layout: single-copy
classes: wide
author_profile: true
author: Pavel Shiryaev
---

## Введение

Суть задания заключается в поэтапной разработке платформы обработки разнотипных задач из очереди.

Рекомендуемое время выполнения: 4 часа.

Ожидаемый результат: репозиторий на GitHub, либо git репозиторий упакованный в архив переданный в ответе на письмо с заданием.

Можно выполнить любой объём задания.

## Требования к технической части проекта

Платформа для разработки: Java 8.

Артефакт проекта: JAR-файл (включающий в себя все зависимости проекта - так называемый uber-jar), запускаемый из консоли как `java -jar <имя файла>`.

Инструмент сборки: Maven, допускается использовать Gradle.

Фреймворк для тестирования: JUnit 4, допускается использование JUnit 5.

Функциональные тесты: допускается использование стека Docker и всевозможных эмуляторов.

VCS: git-репозиторий (можно использовать GitHub). Каждый этап задания рекомендуется выполнять в отдельной ветке, сделанной от ветки предыдущего этапа, или master (для первого этапа).

Библиотеки: допускается использование любых необходимых библиотек как для написания тестов, так и для compile/runtime.

Предпочитаемые форматы конфигурационных файлов: yml, property, xml.

## Критерии оценивания

Критерии перечислены в порядке убывания важности:

1. Работоспособность проекта;
2. Архитектура решения;
3. ход разработки на основе истории git:
  2. законченность и осмысленность коммитов;
  3. атомарность коммитов;
4. наличие и качество юнит-тестов. Тут важна осмысленность и 100% покрытие не требуется;
5. наличие и качество функциональных тестов;
6. документация проекта является плюсом (рекомендуется использовать Markdown).

## Задание

### Этап 1. Обработчик очереди, запуск по расписанию

> Примерное время выполнения - 45 минут

Имеется источник данных (очередь), описанный следующими интерфейсами.

```java
interface Queue {

  public void connect(); // Подключиться к очереди

  public Task getNextTask() throws IllegalStateException; // получить задачу, ошибка - если не был вызван connect(), null - если очередь пуста

  public void disconnect(); // Отключиться от очереди
}

interface Task {

  int getTaskId(); // Уникальный ID задачи

  int getTaskType(); // Тип задачи

  int getPayloadId(); // ID полезной нагрузки - для получения дополнительных данных по конкретной задачи. Вид дополнительных данных зависит от taskType.
}
```

На первом этапе нужно разработать основу обработчика очереди.

Обработчик должен:

* запускаться по расписанию, которое задаётся в конфигурационном файле;
* брать задачи из очереди, до тех пор пока они там есть;
* если задач в очереди нет - отключиться от очереди и запуститься через указанный в конфиге интервал времени;
* логировать задачи взятые из очереди.

### Этап 2. Разнотипные обработчики

> Примерное время выполнения - 45 минут

Примем, что `Task#getTaskType()` может возвращать дискретный набор значений.

Нужно обеспечить возможность обработки задач в зависимости от `taskType`.

Предположим для обработки задачи типа 1 (`getTaskType() == 1 // true`) будет использоваться сервис с интерфейсом:

```java
interface Task1Service {

  void prepareForTask(Task t); // подготовить к испольнению задачи

  Object doTask(Task t); // исполнить задачу и получить результат
}
```

Предположим для обработки задачи типа 2 (`getTaskType() == 2 // true`) будет использоваться асинхронный сервис с интерфейсом:

```java
interface Task2AsyncService {

  int scheduleTask(Task t); // отправить задачу на выполнение, результат - id задачи в подсистеме

  Object getStatus(int subsystemTaskId); // Получить результат выполнения задачи, возвращается гарантированно, если null, значит задача ещё не выполнена.
}
```

Для задач типа `1` и `2`, по финалу их выполнения, нужно сохранить результат, используя интерфейс:

```java
interface TaskResults {
  void saveResult(Task t, Object result);
}
```

### Этап 3. Паралельная обработка задач

> Примерное время выполнения - 1,5 часа

Обработчик очереди должен запускать обработку каждой следующей задачи в отдельном потоке.
Количество потоков должно настраиваться в конфигурационном файле.

Рекомендуется использовать ExecutorService.

### Этап 4. Работа с большими объёмами данных

> Примерное время выполнения - 1 час

Предположим, что задачи из очереди имеющие тип 3 ((`getTaskType() == 3 // true`)) требуют выгрузки на файловую систему большого объёма данных (> 8 Гб).

Для работы с задачами типа `3` нужно использовать сервис с интерфейсом:

```java
interface Task3Service {

  void do(InputStream stream); //Обработать поток данных - внутри происходит полное чтение stream. Передаваемый stream внутри метода не закрывается

}
```

Для получения полезной нагрузки, нужно использовать интерфейс:

```java
interface Task3Payload {

  void init(int payloadId); // Инициализировать источник данных

  String nextLine(); // Возвращает следующую строку или null, если данные закончились

  void finish(); // деинициализироваьт источник данных.

}
```

Нужно доработать обработчик очереди с тем, чтобы обеспечить реализацию этого требования.
Не допускается вычитывание источника данных целиком в память перед тем, как передать управление в `Task3Service`.
